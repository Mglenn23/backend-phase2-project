'use strict'
/* eslint-env mocha */

const { expect } = require('chai')
const utils = require('.')

describe('The utils module interface', function () {
  it('Is an object', function (done) {
    expect(utils).to.be.an.object
    done()
  })
})

describe('lowerSubjectProp function', function () {
  const subjectString = 'SOME SUBJECT with some caps'
  const fn = utils.lowerSubjectProp

  it('Should take an object and return the lower-case "subject" property', function (done) {
    expect(fn).to.be.a.function
    expect(fn({ subject: subjectString })).to.be.a.string
    expect(subjectString.toLowerCase()).to.be.equal(fn({ subject: subjectString }))
    done()
  })
})

describe('dotJoin function', function () {
  const fn = utils.dotJoin
  const intData = [1, 2, 3, 4, 5]
  const strData = ['1', '2', '3', '4', '5']

  it('Should join an array with single dots', function (done) {
    expect(fn(intData)).to.equal(intData.join('.'))
    expect(fn(strData)).to.equal(strData.join('.'))
    done()
  })
})

describe('dotSplit function', function () {
  const fn = utils.dotSplit
  const data = 'a.dot.delimited.string'

  it('Should split a string into an array on each dot', function (done) {
    expect(fn(data)).to.be.an.array
    expect(fn(data).length).to.equal(4)
    done()
  })
})

describe('toInt function', function () {
  const fn = utils.toInt

  it('Should return an int from a stringified int value', function (done) {
    expect(fn('1')).to.equal(1)
    done()
  })

  it('Should return NaN for non-int-coercable strings', function (done) {
    expect(fn('b')).to.be.NaN
    expect(fn('=')).to.be.NaN
    expect(fn('.')).to.be.NaN
    expect(fn('!')).to.be.NaN
    done()
  })
})

describe('combineArrValuesAsSemver function', function () {
  const fn = utils.combineArrValuesAsSemver
  const array1 = [1, 2, 3]
  const curriedFn = fn(array1)
  const wontHappen = [6, 6, 6]
  const realisticMinor = [0, 1, 0]
  const realisticPatch = [0, 0, 1]

  it('Is curried', function (done) {
    expect(fn.length).to.equal(2)
    expect(curriedFn.length).to.equal(1)
    done()
  })

  it('Combines two arrays of values into a new array of semver values', function (done) {
    expect(curriedFn(wontHappen)).to.deep.equal([7, 8, 6])
    done()
  })

  it('If minor is increased, patch will be used directly from the second array param', function (done) {
    expect(curriedFn(realisticMinor)).to.deep.equal([1, 3, 0])
    done()
  })

  it('If minor is not increased, patch will be added to the existing value', function (done) {
    expect(curriedFn(realisticPatch)).to.deep.equal([1, 2, 4])
    done()
  })
})

describe('countMatches function', function () {
  const fn = utils.countMatches
  const array1 = ['b', 'c', 'd']

  it('Counts number of references of all array elements in the string', function (done) {
    expect(fn(array1, 'abcdefghijklmnopqrstuvwxyz')).to.equal(3)
    expect(fn(array1, '')).to.equal(0)
    done()
  })

  it('Is case sensitive', function (done) {
    expect(fn(['A'], 'aaaaaaa')).to.equal(0)
    expect(fn(['A'], 'aaaaa;;;A`/-a')).to.equal(1)
    done()
  })

  it('Matches arbitrarily long strings', function (done) {
    expect(fn(['this is a somewhat long string',
               'usually you wont use this function in this way'],
               'this is a somewhat long string and usually you wont use this function in this way')).to.equal(2)
    done()
  })
})
